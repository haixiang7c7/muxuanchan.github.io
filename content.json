[{"title":"jvm之类加载","date":"2017-09-22T03:48:29.000Z","path":"2017/09/22/jvm之类加载/","text":"此文主要参考《深入理解Java虚拟机》一书，用以整理、巩固和分享jvm相关知识。 jvm的类加载包括五个步骤：加载、验证、准备、解析、初始化。 加载加载包含三个步骤： 1.通过类的全限定名去获取定义此类的二进制字节流 2.将这个字节流所代表的静态存储文件转化为方法区的运行时数据结构 3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 验证验证包括四个步骤： 1.文件格式验证 2.元数据验证 3.字节码验证 4.符号引用验证 准备准备阶段是正式为类变量分配内存并设置变量初始值的阶段，这些变量所使用的内存都将在方法区进行分配 解析解析阶段是将常量池的符号引用替换为直接引用的过程 初始化初始化类变量和其他资源，也就是：执行类构造器()方法 - 双亲委派模型类加载器的双亲委派模型的工作过程是：如果一个类加载器收到了加载类的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 这样的好处是：Java类随着它的类加载器一起具备了一种带有优先级的层次关系。比如，java.lang.Object存放在rt.jar中，无论哪个类加载器要加载这个类，最终都委派给处于模型顶端的启动类加载器进行加载，因此object类在程序的各种类加载器环境中都是同一个类。","comments":true,"categories":[],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://blog.halochen.com/tags/jvm/"}]},{"title":"《刻意练习》读书笔记","date":"2017-09-18T02:54:59.000Z","path":"2017/09/18/刻意练习读书笔记/","text":"最近在读一本书名叫《刻意练习》，在此把我觉得印象比较深刻的点记录一下，无先后顺序之分。目前还未读完整本书，随时看随时进行补充，欢迎留言交流。 1.几乎所有技能都是可以靠刻意练习练成的，包括像莫扎特一样的完美高音。 2.在进行刻意练习的时候需要保持高度的专注。 3.保证练习时的良好状态，因为这会影响你在练习时的专注度。（每次练习不超过一小时，因为长时间的练习会降低专注度，练习中间进行适当的休息；保证前一天晚上的睡眠质量，睡到自然醒最好；中午进行适当的午休；） 4.每次练习要走出舒适区，在比现有能力稍难一点的区域进行练习。 5.进行有目的的练习，每次练习需要完成一定的小目标。 6.制定合理的分步计划并坚定的执行，养成完成计划的习惯。 7.增强影响执行计划的积极因素，削弱消极因素。（比如：每天专门留出一块完整的不受打扰的时间来进行可以练习，如果会受到手机影响则关闭手机等） 8.任何真正的刻意练习对任何人来说一开始都是不舒服的（那些某个领域的顶尖人才也不例外，而且他们对于不擅长的领域的练习也仍旧会和普通人一样有这种不适感），只是这种不舒服的感觉会随着你练习的次数慢慢缓解，最后你就会感觉不到这种不适，那时你已经成功培养了刻意练习的习惯。 9.培养并保持强烈的动机，把外部的动机转化成内在的动机。这点可能是最重要的。","comments":true,"categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.halochen.com/tags/读书笔记/"}]},{"title":"ElasticSearch实战经验总结","date":"2017-08-09T05:55:02.000Z","path":"2017/08/09/ElasticSearch实战经验总结/","text":"最近产品中增加了搜索的需求，同时需要根据不同的维度来排列搜索结果，普通的sql排序已无法满足需求，因此需要一款搜索引擎来解决这个问题，网上搜索了一番发现目前比较流行的一款产品ElasticSearch，简单了解之后发现它功能强大天生支持分布式且容易上手，很适合作为我们产品的搜索引擎。本文接下来将简单介绍一下相关的实战经验，即作为本人的归纳总结，也是给其他想要采用ElasticSearch（下文简称ES）的人一个参考。 下载安装要想使用ES的第一步必然是先下载安装了，我们打开ES官网下载页，上面很清晰地展示了5个步骤要做的事情，分别是：1.下载Elasticsearch，2.下载Kibana，3.安装X-Pack（安全、监控软件，非必需，如果只是在本地测试用的话可以不装，装了之后在打开kibana界面的时候会要求输入密码），4.启动elasticsearch和kibana，5.打开浏览器输入kibana的地址，访问kibana（注：kibana是ES官方推出的图形化管理工具，可以配合ES使用，后面也用到）。 使用kibana操作ES1.创建index pattern如果在上一步已经成功安装了所需的软件，那么现在我们就可以使用kibana来做一个es相关的操作了。首先当你输入地址打开kibana的时候，我们会看到像下图一样的界面。 页面的最上方有一条红色的提示，它的意思是在提醒我们目前还没指定一个索引模式，所以我们要做的第一步就是填写一个索引模式，比如“topanchor*”，星号代表匹配任何字符，它会去匹配你在ES中建立的所有索引，如果和这个模式匹配上就会在kibana中显示出来。 2.创建index做好了前面的准备工作之后，现在我们要真正来使用ES做一些事情了。最终我们想要的是利用ES来搜索我们想要的数据，所以首先得有数据，录入数据的第一步就是创建索引，索引可以类比成数据库，就像我们在往数据库录入数据的时候首先得创建一个数据库。创建index的语句如下： 123456789PUT /my_index&#123; &quot;settings&quot;: &#123; ... any settings ... &#125;, &quot;mappings&quot;: &#123; &quot;type_one&quot;: &#123; ... any mappings ... &#125;, &quot;type_two&quot;: &#123; ... any mappings ... &#125;, ... &#125;&#125; 其中的settings字段可以指定词义分析器、分词器等个性化设置，比如可以选择不同的分词器来生成不同需求的索引，mapping字段是对index的type进行设置，这里的type就好比数据库中的表，一个数据库可以创建多张表，同理这里可以设置多个type，对type中的字段进行设置，比如指定字段索引的时候用哪个分词器，搜索的时候用哪个分词器等，我们可以根据自身的需求创建不同的index，建好了索引之后我们就可以开始往索引中索引（此处的索引为动词，是ES中的专有名词）数据，以供后续的搜索。 建好索引之后，我们可以对其设置别名，完成别名设置以后就可以使用这个别名来对这个索引进行操作。索引别名就像一个快捷方式或软连接，可以指向一个或多个索引，也可以给任何一个需要索引名的API来使用。别名带给我们极大的灵活性，在我们的应用中应该使用别名而不是索引名。然后我们就可以在任何时候重建索引。别名的开销很小，应该广泛使用。下面的代码为my_index这个索引创建了一个名为my_index_v1的别名。 1PUT /my_index_v1/_alias/my_index 3.索引数据索引数据就是把我们需要进行搜索的数据集根据索引规则存到ES里。索引语句如下： 1234567PUT /topanchor/circle/_bulk&#123; &quot;index&quot;:&#123; &quot;_id&quot; : 7 &#125;&#125;&#123;&quot;circleId&quot;:&quot;13&quot;,&quot;circleName&quot;: &quot;lalal&quot;,&quot;circleMaster&quot;:&quot;yaoyao&quot;,&quot;memberNum&quot;: 16,&quot;postNum&quot;:3,&quot;taskNum&quot;:5,&quot;isV&quot;:1,&quot;timeCreated&quot;:1494295496634,&quot;dateCreated&quot;:&quot;2017-05-20&quot;&#125;&#123; &quot;index&quot;:&#123; &quot;_id&quot; : 2 &#125;&#125;&#123;&quot;circleId&quot;:&quot;222&quot;,&quot;circleName&quot;: &quot;pdd&quot;,&quot;circleMaster&quot;:&quot;pdd本尊&quot;,&quot;memberNum&quot;:23,&quot;postNum&quot;:6,&quot;taskNum&quot;:1,&quot;isV&quot;:0,&quot;timeCreated&quot;:1494295423634,&quot;dateCreated&quot;:&quot;2017-05-21&quot;&#125;&#123; &quot;index&quot;:&#123; &quot;_id&quot; : 3 &#125;&#125;&#123;&quot;circleId&quot;:&quot;333&quot;,&quot;circleName&quot;:&quot;55开的游戏&quot;,&quot;circleMaster&quot;: &quot;55开&quot;,&quot;memberNum&quot;:56, &quot;postNum&quot;:26,&quot;taskNum&quot;:4,&quot;isV&quot;:1,&quot;timeCreated&quot;:1494295423321,&quot;dateCreated&quot;:&quot;2017-05-22&quot;&#125; 这里同时向索引为topanchor，type为user的数据集里添加了三条数据。有了数据之后我们就可以对这些数据进行搜索了。 4.搜索数据ES的强大在于设置合适的索引和运用合适的搜索语句几乎可以实现任何你想要的搜索规则。这里例举几个常用的搜索方法： 普通搜索（指定返回的条数） 12345GET /topanchor/circle/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;size&quot;:100&#125; 高级搜索（根据自己的需求定制） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869GET topanchor/circle/_search&#123; &quot;explain&quot;: false, &quot;from&quot; : 0, &quot;size&quot; : 10,//返回搜索到的前10条数据 &quot;query&quot;: &#123;//bool 过滤器 &quot;bool&quot;: &#123;//条件集 &quot;must&quot;: [//必须要匹配的项，相当于AND &#123; &quot;function_score&quot;: &#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;circleName&quot;: &quot;lalal&quot; &#125; &#125;, &quot;functions&quot;: [ //得分规则 &#123; &quot;linear&quot;: &#123; &quot;dateCreated&quot;: &#123; &quot;origin&quot;: &quot;2017-05-30&quot;, &quot;offset&quot;: &quot;0d&quot;, &quot;scale&quot;: &quot;365d&quot; &#125; &#125; &#125;, &#123; &quot;field_value_factor&quot;: &#123; &quot;field&quot;: &quot;memberNum&quot;, &quot;factor&quot;: 5 &#125; &#125;, &#123; &quot;field_value_factor&quot;: &#123; &quot;field&quot;: &quot;postNum&quot;, &quot;factor&quot;: 2.5 &#125; &#125;, &#123; &quot;field_value_factor&quot;: &#123; &quot;field&quot;: &quot;taskNum&quot;, &quot;factor&quot;: 2.5 &#125; &#125;, &#123; &quot;field_value_factor&quot;: &#123; &quot;field&quot;: &quot;isV&quot;, &quot;factor&quot;: 1.5 &#125; &#125; ], &quot;score_mode&quot;: &quot;sum&quot;, //搜索分数的计算规则，这里是相加 &quot;boost_mode&quot;: &quot;replace&quot;//和原有得分的处理方式，这里是替换 &#125; &#125; ], &quot;should&quot;: [//选择性匹配项，相当于OR &#123;&quot;constant_score&quot;: &#123; &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;circleName.origin&quot;: &quot;pdd&quot; &#125; &#125;, &quot;boost&quot;: 100000 //得分 &#125;&#125; ] &#125; &#125;&#125; 总结今天简单介绍了ES入门相关的东西，相当于学习一门新的编程语言时介绍的helloworld，ES还有很多有用且强大的方法特性等着你去发掘，在此推荐几个文档，是我学习ES时主要参考的文档，以后需要用到什么去翻翻这几个文档基本上都能找到解决办法，希望大家早日耍得溜ES，good luck !! 参考文档： 1.Elasticsearch: 权威指南 2.elasticsearch-guide 3.通过Function Score Query优化Elasticsearch搜索结果","comments":true,"categories":[],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://blog.halochen.com/tags/搜索/"}]},{"title":"java中间件系列之dubbo入门","date":"2017-02-22T08:42:43.000Z","path":"2017/02/22/java中间件系列之dubbo入门/","text":"前言鉴于目前各个互联网公司都在打造自己的分布式服务系统，而分布式系统中又会涉及到各种常用的中间件，故决定花时间把当前流行的使用率比较高的几个中间件深入学习一下。千里之行始于足下，因工作原因今天就先挑一个分布式服务框架Dubbo来学习一番入个门。 需求为什么我们需要用到dubbo这个框架呢？Dubbo wiki官方是这样介绍的： 在大规模服务化之前，应用可能只是通过RMI或Hessian等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。 1.当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。 此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。 并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。 2.当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系。 3.接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？ 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。 其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。 概述Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。 Dubbo采用全spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。 架构 节点角色说明： Provider: 暴露服务的服务提供方。 Consumer: 调用远程服务的服务消费方。 Registry: 服务注册与发现的注册中心。（可选，本文用zookeeper作为注册中心） Monitor: 统计服务的调用次调和调用时间的监控中心。（可选，本文不需要） Container: 服务运行容器。（可选，本文不需要） 调用关系说明： 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 实例首先上网站http://www.apache.org/dyn/closer.cgi/zookeeper/下载一个zookeeper,下载后直接解压不用安装。 在启动zookeeper之前需要先改一下配置文件，因为Zookeeper在启动时会找名为zoo.cfg的文件作为默认配置文件，所以我们要去conf目录下，把zoo_sample.cfg改名为zoo.cfg，并把其中的配置项dataDir改为你喜欢的目录，比如我的是：dataDir=/Users/Halo/Downloads/zookeeper-3.4.9/dataTmp 配置项含义tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。 dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据 的日志文件也保存在这个目录里。 dataLogDir：顾名思义就是 Zookeeper 保存日志文件的目录 clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。 当这些配置项配置好后，现在就可以启动Zookeeper了，zookeeper的启动脚本在bin目录下，找到对应系统的脚本zkServer启动即可，启动后要检查Zookeeper是否已经在服务，可以通过netstat –ano命令查看是否有你配置的clientPort端口号在监听服务。启动成功后请把运行脚本的窗口一直打开，而且要在程序运行之前就打开，这样zookeeper服务才会一直有效运行。 由于zookeeper界面显示目前有哪些提供者或消费者，所以我们需要通过Dubbo-Admin管理平台来实时的查看，也可以通过这个平台来管理提者和消费者。 配置dubbo-admindubbo的所有源码可上https://github.com/alibaba/dubbo下载，下载之后解压进入dubbo-admin文件夹，运行命令 mvn package -Dmaven.skip.test=true 打包，打包成功之后进入targe目录，把war包放到Tomcat webapps目录下，启动tomcat，此时会把war包解压出来，进入WEB-INF目录，里面有个dubbo.properties文件，内容如下： dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.admin.root.password=root dubbo.admin.guest.password=guest 如果是本地运行，则不用修改address属性，否则改成你部署zookeeper的机器的地址。然后先启动zookeeper，再启动tomcat，（注意这里启动顺利不能改变），然后访问dubbo-admin项目，输入用户名密码即可进入管理首页。 服务提供者新建一个maven项目dubbo-provide创建ProviderService接口，代码如下： 123public interface ProviderService &#123; public String sayHello(String name);&#125; 创建ProviderServiceImpl实现类，代码如下： 12345public class ProviderServiceImpl implements ProviderService &#123; public String sayHello(String name) &#123; return \"hello!\"+name; &#125;&#125; 创建spring配置文件applicationProvider： 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd \"&gt; &lt;!-- 具体的实现bean --&gt; &lt;bean id=\"providerService\" class=\"com.halo.service.ProviderServiceImpl\" /&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=\"dubbo_provider\" /&gt; &lt;!-- 使用multicast广播注册中心暴露服务地址 &lt;dubbo:registry address=\"multicast://localhost:1234\" /&gt;--&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\" /&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"29014\" /&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=\"com.halo.service.ProviderService\" ref=\"providerService\" /&gt;&lt;/beans&gt; 修改pom.xml文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.halo&lt;/groupId&gt; &lt;artifactId&gt;dubbo_provide&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;spring.version&gt;3.2.16.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;version&gt;2.5.6.SEC03&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建测试文件ProviderServiceTest： 1234567891011121314public class ProviderServiceTest &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext( new String[]&#123;\"applicationProvider.xml\"&#125;); context.start(); System.out.println(\"提供者服务已注册成功\"); System.out.println(\"请按任意键取消提供者服务\"); try &#123; System.in.read();//让此程序一直跑，表示一直提供服务 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行ProviderServiceTest的main方法，启动服务提供者，此时就能在dubbo-admin页面上查看到这个服务提供者。 服务消费者新建一个maven项目dubbo-consumer，打包dubbo-provide项目，然后把打包生成的jar包添加到dubbo-consumer项目里。 创建applicationConsumer.xml文件： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd \"&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=\"dubbo_consumer\" /&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry protocol=\"zookeeper\" address=\"zookeeper://127.0.0.1:2181\" /&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=\"providerService\" interface=\"com.halo.service.ProviderService\" /&gt;&lt;/beans&gt; 修改pom.xml文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.halo&lt;/groupId&gt; &lt;artifactId&gt;dubbo_consumer&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;spring.version&gt;3.2.16.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 添加provider的jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.halo&lt;/groupId&gt; &lt;artifactId&gt;dubbo_provide&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加dubbo依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 添加zk客户端依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建ProviderServiceTest文件： 123456789101112131415161718public class ConsumerServiceTest &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext( new String[] &#123; \"applicationConsumer.xml\" &#125;); context.start(); ProviderService providerService = (ProviderService) context.getBean(\"providerService\"); System.out.println(providerService.sayHello(\"halo\")); System.out.println(\"Press any key to exit.\"); try &#123; System.in.read();//防止进程结束 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行dubbo-consumer的main方法，如果正常输出打印结果则服务调用成功。至此整个dubbo服务的入门就结束，欢迎留言讨论。","comments":true,"categories":[],"tags":[{"name":"java中间件","slug":"java中间件","permalink":"http://blog.halochen.com/tags/java中间件/"},{"name":"dubbo","slug":"dubbo","permalink":"http://blog.halochen.com/tags/dubbo/"}]},{"title":"用hexo和github pages搭建博客","date":"2017-01-09T13:39:02.000Z","path":"2017/01/09/firstBlog/","text":"前言花了一晚上时间把这个博客搭起来了，前期经过了解对比之后决定选用 hexo + github pages这套方案，原因是简洁、快捷、轻量，比较适合我。在折腾了一段时间后，终于把本博客打造成我喜欢的样式了，主要是在hexo的yilia的基础上进行个性化定制，如果喜欢本博客的样式，可以下载我定制的主题luna，其他再推荐一个人气很高的主题next，好了，废话不多说，下面就开始用hexo+github搭建我们的博客吧。 原理用这套技术搭建博客的原理就是：用静态页面生成静态博客。 gitHub pages本用于介绍托管在GitHub的项目,不过由于他的空间免费稳定，用来做搭建一个博客再好不过了。github pages可以被认为是用户编写的、托管在github上的静态网页。 安装hexo万里长征的第一步当然是先安装hexo，很简单，上hexo官网对照着教程做就可以了，当你在命令行中输入hexo -v能看到hexo的版本号并且没有其他错误提示，那么恭喜你，已经有了一个好的开头。 创建github项目上github官网创建一个特别的项目，名字格式为yourname.github.io，比如你的github用户名为halochen90，那我这个项目的名字就是halochen90.github.io,同理创建你自己的项目。 创建本地项目上一步我们已经在github上面创建好了项目，现在我们就可以在本地新建一个我们的博客项目，比如项目名为：HexoProject。并把它与上一步的**.github.io关联起来，以后我们每次写博客的时候，只要把本地项目推送到github上就能发布新的博客。接下来， 进入HexoProject的根目录： 1cd HexoProject; 部署hexo 1hexo init 创建新博文 1hexo new [layout] &quot;postName&quot; 生成站点文件 1$ hexo generate 运行服务器 1$ hexo server hexo默认启动的是本地的4000端口，此时打开浏览器输入就可以看到你的额博客了。 部署到github进入博客项目的根目录，编辑_config.yml配置文件 1234deploy: type: git repository: git@github.com:**.github.io.git branch: master 然后输入 1$ hexo deploy 这样博客就更新到了github上。 更换主题hexo更换主题很简单，先把你喜欢的主题down到本地，并放到博客项目的themes文件夹，然后修改博客项目根目录的_config.yml文件就可以，把里面的theme字段改成你刚down下来的主题的文件夹名就OK。重新hexo g更新文件，hexo s启动服务就可以看到新的主题。 后记其他还有关于域名绑定，以及第三方服务集成等等可以自行Google，网上有很多教程在此就不再赘述了，如果还有不懂的地方或者文中有错误的地方，请在下方给我留言。","comments":true,"categories":[],"tags":[{"name":"技术周边","slug":"技术周边","permalink":"http://blog.halochen.com/tags/技术周边/"}]}]